<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Highway Runner</title>
<style>
  body { margin:0; overflow:hidden; background:#222; font-family:sans-serif; }
  #score { position:fixed; top:20px; left:20px; color:white; font-size:24px; z-index:10; }
  #leftBtn, #rightBtn { position:fixed; bottom:30px; width:60px; height:60px; font-size:30px; opacity:0.7; border-radius:10px; user-select:none; }
  #leftBtn { left:30px; }
  #rightBtn { right:30px; }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<button id="leftBtn">⬅️</button>
<button id="rightBtn">➡️</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

// Scene
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x444444);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,3,7);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dir = new THREE.DirectionalLight(0xffffff, 1);
dir.position.set(5,10,5);
scene.add(dir);

// Road
const road = new THREE.Mesh(
  new THREE.PlaneGeometry(6,1000),
  new THREE.MeshStandardMaterial({color:0x333333})
);
road.rotation.x = -Math.PI/2;
road.position.z = -500;
scene.add(road);

// Lane lines
for(let i=1;i<3;i++){
  const line = new THREE.Mesh(
    new THREE.PlaneGeometry(0.1,1000),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  line.rotation.x = -Math.PI/2;
  line.position.x = -2 + i*2;
  line.position.z = -500;
  line.position.y = 0.01;
  scene.add(line);
}

// Loader
const loader = new GLTFLoader();

// Placeholder boxes (always visible)
let car = new THREE.Mesh(new THREE.BoxGeometry(1,1,2), new THREE.MeshStandardMaterial({color:0xff0000}));
car.position.set(0,0.5,0);
scene.add(car);

let obstacles = [];
let coins = [];

// URLs
const CAR_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/cartoon_car.glb';
const OBSTACLE_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/spikeball_obstacles.glb';
const COIN_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/coins.glb';

// Load actual GLBs (replace placeholder when loaded)
loader.load(CAR_URL, gltf=>{
  gltf.scene.scale.set(0.01,0.01,0.01);
  gltf.scene.position.copy(car.position);
  scene.remove(car);
  car = gltf.scene;
  scene.add(car);
}, undefined, ()=>console.warn("Car GLB failed to load"));

function spawnObstacle(){
  const obsPlaceholder = new THREE.Mesh(new THREE.BoxGeometry(1,1,2), new THREE.MeshStandardMaterial({color:0x00ff00}));
  obsPlaceholder.position.set([-2,0,2][Math.floor(Math.random()*3)],0.5,-50);
  scene.add(obsPlaceholder);
  obstacles.push(obsPlaceholder);

  loader.load(OBSTACLE_URL, gltf=>{
    gltf.scene.scale.set(0.01,0.01,0.01);
    gltf.scene.position.copy(obsPlaceholder.position);
    scene.remove(obsPlaceholder);
    scene.add(gltf.scene);
    obstacles[obstacles.indexOf(obsPlaceholder)] = gltf.scene;
  }, undefined, ()=>console.warn("Obstacle GLB failed"));
}

function spawnCoin(){
  const coinPlaceholder = new THREE.Mesh(new THREE.BoxGeometry(0.5,0.5,0.5), new THREE.MeshStandardMaterial({color:0xffff00}));
  coinPlaceholder.position.set([-2,0,2][Math.floor(Math.random()*3)],0.5,-50);
  scene.add(coinPlaceholder);
  coins.push(coinPlaceholder);

  loader.load(COIN_URL, gltf=>{
    gltf.scene.scale.set(0.01,0.01,0.01);
    gltf.scene.position.copy(coinPlaceholder.position);
    scene.remove(coinPlaceholder);
    scene.add(gltf.scene);
    coins[coins.indexOf(coinPlaceholder)] = gltf.scene;
  }, undefined, ()=>console.warn("Coin GLB failed"));
}

// Controls
let left=false, right=false;
document.getElementById('leftBtn').addEventListener('touchstart',()=>left=true);
document.getElementById('leftBtn').addEventListener('touchend',()=>left=false);
document.getElementById('rightBtn').addEventListener('touchstart',()=>right=true);
document.getElementById('rightBtn').addEventListener('touchend',()=>right=false);

// Game variables
const lanes = [-2,0,2];
let score=0;
const scoreEl = document.getElementById('score');
let clock = new THREE.Clock();
let obstacleTimer=0, coinTimer=0;

// Animate
function animate(){
  requestAnimationFrame(animate);
  const delta = clock.getDelta();

  // Car move
  if(left) car.position.x = Math.max(lanes[0], car.position.x-0.2);
  if(right) car.position.x = Math.min(lanes[2], car.position.x+0.2);

  // Spawn obstacles and coins
  obstacleTimer += delta;
  if(obstacleTimer>1){ spawnObstacle(); obstacleTimer=0; }

  coinTimer += delta;
  if(coinTimer>1.5){ spawnCoin(); coinTimer=0; }

  // Move obstacles
  obstacles.forEach((obs,i)=>{
    obs.position.z += 0.5;
    if(obs.position.z > camera.position.z+5){ scene.remove(obs); obstacles.splice(i,1); }
    if(car.position.distanceTo(obs.position)<1.5){ alert("Game Over! Score:"+Math.floor(score)); location.reload(); }
  });

  // Move coins
  coins.forEach((coin,i)=>{
    coin.position.z +=0.5;
    coin.rotation.x += delta*5;
    coin.rotation.y += delta*5;
    if(coin.position.z > camera.position.z+5){ scene.remove(coin); coins.splice(i,1); }
    if(car.position.distanceTo(coin.position)<1.5){ score+=10; scoreEl.textContent='Score:'+Math.floor(score); scene.remove(coin); coins.splice(i,1); }
  });

  score +=0.1;
  scoreEl.textContent='Score:'+Math.floor(score);

  renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
