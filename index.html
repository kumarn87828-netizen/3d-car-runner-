<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Highway Runner</title>
<style>
  body { margin:0; overflow:hidden; background:#222; font-family:sans-serif; }
  #score { position:fixed; top:20px; left:20px; color:white; font-size:24px; z-index:10; }
  #leftBtn, #rightBtn { position:fixed; bottom:30px; width:60px; height:60px; font-size:30px; opacity:0.7; border-radius:10px; user-select:none; }
  #leftBtn { left:30px; }
  #rightBtn { right:30px; }
</style>
</head>
<body>

<div id="score">Score: 0</div>
<button id="leftBtn">⬅️</button>
<button id="rightBtn">➡️</button>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js';
import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/loaders/GLTFLoader.js';

// Scene setup
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x222222);
const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
camera.position.set(0,3,7);
camera.lookAt(0,0,0);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// Lights
scene.add(new THREE.AmbientLight(0xffffff, 1));
const directional = new THREE.DirectionalLight(0xffffff, 1);
directional.position.set(10,10,10);
scene.add(directional);

// Road
const roadGeo = new THREE.PlaneGeometry(6, 1000);
const roadMat = new THREE.MeshStandardMaterial({color:0x333333});
const road = new THREE.Mesh(roadGeo, roadMat);
road.rotation.x = -Math.PI/2;
road.position.z = -500;
scene.add(road);

// Lane lines
for(let i=1;i<3;i++){
  const lineGeo = new THREE.PlaneGeometry(0.1, 1000);
  const lineMat = new THREE.MeshStandardMaterial({color:0xffffff});
  const line = new THREE.Mesh(lineGeo,lineMat);
  line.rotation.x = -Math.PI/2;
  line.position.x = -2 + i*2;
  line.position.y = 0.01;
  line.position.z = -500;
  scene.add(line);
}

// Loader
const loader = new GLTFLoader();
let car, obstacles=[], coins=[];

// GitHub Pages URLs
const CAR_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/cartoon_car.glb';
const OBSTACLE_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/spikeball_obstacles.glb';
const COIN_URL = 'https://kumarn87828-netizen.github.io/3d-car-runner-/coins.glb';

// Placeholder cube while car loads
const placeholder = new THREE.Mesh(
  new THREE.BoxGeometry(1,1,2),
  new THREE.MeshStandardMaterial({color:0xff0000})
);
placeholder.position.set(0,0.5,0);
scene.add(placeholder);

// Load player car
loader.load(CAR_URL, gltf=>{
    car = gltf.scene;
    car.scale.set(0.01,0.01,0.01);
    car.position.set(0,0.5,0);
    scene.add(car);
    scene.remove(placeholder);
}, undefined, ()=>{
    console.warn("Car GLB failed to load, placeholder visible.");
});

// Touch controls
let leftPressed=false, rightPressed=false;
document.getElementById('leftBtn').addEventListener('touchstart', e=>{ leftPressed=true; e.preventDefault(); });
document.getElementById('leftBtn').addEventListener('touchend', e=>{ leftPressed=false; e.preventDefault(); });
document.getElementById('rightBtn').addEventListener('touchstart', e=>{ rightPressed=true; e.preventDefault(); });
document.getElementById('rightBtn').addEventListener('touchend', e=>{ rightPressed=false; e.preventDefault(); });

// Lanes
const lanes = [-2,0,2];
function randomLane(){ return lanes[Math.floor(Math.random()*lanes.length)]; }

// Load obstacles
function loadObstacle(){ 
    loader.load(OBSTACLE_URL, gltf=>{
        const obs = gltf.scene;
        obs.scale.set(0.01,0.01,0.01);
        obs.position.set(randomLane(),0.5,-50);
        scene.add(obs);
        obstacles.push(obs);
    }, undefined, ()=>{
        console.warn("Obstacle GLB failed to load.");
    });
}

// Load coins
function loadCoin(){
    loader.load(COIN_URL, gltf=>{
        const coin = gltf.scene;
        coin.scale.set(0.01,0.01,0.01);
        coin.position.set(randomLane(),0.5,-50);
        scene.add(coin);
        coins.push(coin);
    }, undefined, ()=>{
        console.warn("Coin GLB failed to load.");
    });
}

// Game variables
let score=0, gameOver=false;
const scoreEl = document.getElementById('score');
const clock = new THREE.Clock();
let obstacleTimer=0, coinTimer=0;

// Animate
function animate(){
    requestAnimationFrame(animate);
    if(gameOver) { renderer.render(scene,camera); return; }
    const delta = clock.getDelta();

    // Car movement
    if(car){
      if(leftPressed) car.position.x = Math.max(lanes[0], car.position.x-0.2);
      if(rightPressed) car.position.x = Math.min(lanes[2], car.position.x+0.2);
    }

    // Spawn obstacles
    obstacleTimer += delta;
    if(obstacleTimer > 1){ loadObstacle(); obstacleTimer=0; }

    // Spawn coins
    coinTimer += delta;
    if(coinTimer > 1.5){ loadCoin(); coinTimer=0; }

    // Move obstacles
    obstacles.forEach((obs,i)=>{
        obs.position.z += 0.5;
        if(obs.position.z > camera.position.z+5){ scene.remove(obs); obstacles.splice(i,1); }
        if(car && car.position.distanceTo(obs.position)<1.5){ gameOver=true; alert("Game Over! Score: "+Math.floor(score)); }
    });

    // Move coins
    coins.forEach((coin,i)=>{
        coin.position.z += 0.5;
        coin.rotation.x += delta*5;
        coin.rotation.y += delta*5;
        if(coin.position.z > camera.position.z+5){ scene.remove(coin); coins.splice(i,1); }
        if(car && car.position.distanceTo(coin.position)<1.5){ score+=10; scoreEl.textContent='Score: '+Math.floor(score); scene.remove(coin); coins.splice(i,1); }
    });

    // Score
    score += 0.1;
    scoreEl.textContent='Score: '+Math.floor(score);

    renderer.render(scene,camera);
}
animate();
</script>

</body>
</html>
